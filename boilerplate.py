# Daniel Ryaboshapka and Sam Chung 
# Robula+ Implementation in Python 3.7 
# 

# ALL COMMENTS ABOVE TRANSITION FUNCTIONS PROVIDED BY ROBULA+ AUTHORS 
# INSERT LINK HERE

### NAME DEFINITIONS 
#  xp = The XPATH expression to specialize --> //td 
#  N  = The length (in nodes/levels) of variable xp --> //td => N=1
#														//*//td => N=2
#  L  = The list of the ancestors of target elem e in the considered DOM,
#       starting and including e 
### 

### EXTRA NOTES FROM PAPER ### 
# The algorithm starts its execution by retrieving the element e selected by the absolute XPath abs
# and initializing the list xpList of XPath expressions with the most general one (i.e., “//*”)
# Then, it iterates (line 5) until a result (i.e., an XPath locator) is found (line 18). 
# At each cycle, it removes the first XPath expression (xp) from the list xpList and it applies, 
# in the established order, seven transformations [see below]. 
#
# All the XPath expressions generated by applying these transformations are inserted into a list
# named temp. At this point (line 16), the algorithm cycles through the XPath expressions contained
# in temp, considering in turn each XPath expression x. 
# 
# If x is a unique locator for the target element e (the function uniquelyLocate 
# is used to determine this), the algorithm returns it and terminates.
# Otherwise, by construction we know that x selects more elements than desired, among which the
# target one is included. Thus, x is inserted into the list xpList, 
# to be specialised in the next iterations of the algorithm (i.e., the target element is among
# the elements retrieved by these XPath expressions, whose result set 
# contains more than one element). The actual implementation of ROBULA+ employs
# a data-structure containing all the useful information 
# (e.g., tag name, attributes, positions) of thetarget element and its ancestors 
# up to the root node. During the creation of such data-structure, for
# each element it computes also the power-set of its attributes.
#
# Since ROBULA+ returns the first locator found (i.e., the one that is considered as the
# most robust), it is very important to consider (1) the order of execution 
# of the transformations; and, (2) the order in which each transformation 
# returns its results (this second aspect will be considered in Section 3.4).
# At each iteration of the main cycle (line 5), all the transformations 
# could potentially be executed and thus an order of execution must be defined.
#
#
###

### DESIGN CHOICES ### 





### FILLING PARAMETERS ### 

### 



### ROADMAP THRU 7 TRANSITIONS ###


### 7 TRANSITIONS 

# Precondition: Xpath xp starts with //* 
#       Action: replace initial * with tag name of the DOM elem L.get(N)
#      Example: INPUT:  xp = //*/td and L.get(2).getTagName() = tr  
#				OUTPUT: //tr//td
def transfConvertStar(xp, tagname):

# Precondition: the Nth level of xp does not already contain any kind of predicates
#       Action: Add the predicate basd on the id (if available) of the DOM element L.get(N)
#               to the higher level of xp 
#      Example: INPUT:  xp = //td and L.get(1).getID() = 'name'
#         		OUTPUT: //td[@id='name']
def transfAddID(xp, nth):

# Precondition: the Nth level of xp does not already contain any predicate on text
# 				or any predicate on position
#       Action: add a predicate on the text contained (if any) in the DOM element L.get(N)
#				to the higher level of xp 
#      Example: INPUT:  xp == //td & L.get(1).getText() = 'John' 
#				OUTPUT: //td[contains(text(), 'John')]
def transfAddText(xp, tag):

# Precondition: the Nth level of xp does not contain already any kind of predicates 
#       Action: for each available attribute-value pair of the DOM element L.get(N), generate a 
#				candidate locator by adding a predicate based on such value 
#				to the higher level of xp
#      Example: INPUT:  xp = //tr/td & L.get(2).getAttributes() = {name='data', class='table-row'}
#				OUTPUT: //tr[@name='data']/td & //tr[@class='table-row']/td
def transfAddAttribute(xp, attributes):

# Precondition: the Nth level of xp does not contain already any kind of predicates 
#       Action: for each elem (with cardinality > 1) of the powerset generated from the set of all
# 				attribute-value pairs of the DOM element L.get(N), generate a candidate locator by
#				adding a predicate based on such element to the higher level of xp 
#      Example: INPUT:  xp = //tr/td and L.get(2).getAttributes() = {name='data', class='table-row'}
#				OUTPUT: //tr[@name='data' and @class='table-row']/td <== IS THIS RIGHT???
def transfAddAttributeSet():

# Precondition: the Nth level of xp does not contain already any predicate on position
#       Action: add the position of the element L.get(N) to the higher level of xp 
#      Example: INPUT:  xp = //tr/td and L.get(2).getPosition() = {if tag-name=2, if '*'=3}
#				OUTPUT: //tr[2]/td
def transfAddPosition():

# Precondition: N < L.length()
#       Action: add //* at the top of xp 
#      Example: INPUT:  //tr//td
#				OUTPUT: //*/tr/td
def transfAddLevel():


### AUXILARY FUNCTIONS 

# returns the element in dom selected by the xpath locator xpath
def eval(xpath, dom):

# TRUE iff eval(x, d) contains only e
def uniquelyLocate(xpath, elem):

